---
layout: post
title: "Sort Algorithm(2)"
subtitle: "Data Struct"
author": "Rex Ma"
date: 2015-12-17 13:50:35
header-img: "img/post-bg-01.jpg"
---
在叙述完Heap(堆)的两个重要的性质以及操作之后~我们大概清楚了~堆排序是利用了堆序性以及堆的DeleteMin性质，所以这次继续探讨排序算法。

#堆排序（Heap Sort）

利用堆序性以及DeleteMin操作的确可以对堆进行排序操作~但是我们需要另一个数组进行辅助，可是当我对我的内存空间的要求比较苛刻的话~如何才能解决呢~？

**利用DeleteMin产生的空穴**，熟悉堆的下滤(procateDown)操作的人都知道可以堆在删除最小（最大值）之后会产生一个空穴，那么我们大可以把删除的数据保存在空穴当中。当你需要一个从小到大的排序结果时，最好使用**大根堆（根节点最大的堆）**，这样话的~经过n-1次操作，你就可以得到一个排序好的数组了。之前答应要完成的堆排序算法已经OK了~但是使用Objective-C编写的，但原理都一样~[算法链接](https://github.com/RexMa88/HeapSort)~=_=

#归并排序（Merge Sort）

再说Merge sort之前，先说另一个概念，**分治法(divide and conquer)**这种方法在麻省理工算法公开课的第一节课就被提及了~大意是把一个大的问题分解成若干小的问题去解决，我个人很喜欢分治法的这个概念，因为这个概念包含了哲学理念和方法论，在生活中也会应用到。

#快速排序（Quick Sort）

说起这个快速排序的发明人：Tony Hoare可真是个天才级别的人物啊，快排只是他的其中一个发明而已。Quick sort也利用分治法和递归，这里给出C的[算法链接](https://github.com/RexMa88/Quick-Sort)。

快排的主要思想是利用一个**枢纽元pivot**进行一次排序，一次排序之后pivot左边是小于pivot的数字集合，右边是大于pivot的数字集合。之后利用递归的思想对左边和右边的集合再去进行一趟排序。反复进行分治和递归，排序就成功了。

###关于枢纽元的选取

但是快排的Pivot选取十分的重要~如果你的Pivot选取是很糟糕的话~快排最坏的时间复杂度是O(n^2)，而**三数中值分割法**是一种很不错的方法。比如一个随机数组：8，1，4，9，6，3，5，2，7，0.左边的数值是8，右边的数值是0，中间的数值是L[(Left + Right)/2] = 6，所以Pivot = 6，这种方法虽然不能完全避免快排的最坏情况，但是可以在一定程度上避免最坏情况。

###分割策略

关于快速排序的分割策略虽然形式上不一样~但意思大都一样~都是使用Pivot进行分割~唯一的不同只是在**大话数据结构**这本书中是将Pivot直接在原数组中进行交换，而**数据结构预算法分析**这本书中则是使用了把Pivot放到了最后~之后让数组直接进行一趟排序，Pivot不在中间进行任何比较，只在最后的时候插到中间。
