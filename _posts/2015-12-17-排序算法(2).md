---
layout: post
title: "Sort Algorithm(2)"
subtitle: "Data Struct"
author": "Rex Ma"
date: 2015-12-17 13:50:35
header-img: "img/post-bg-01.jpg"
---
在叙述完Heap(堆)的两个重要的性质以及操作之后~我们大概清楚了~堆排序是利用了堆序性以及堆的DeleteMin性质，所以这次继续探讨排序算法。

#堆排序（Heap Sort）

利用堆序性以及DeleteMin操作的确可以对堆进行排序操作~但是我们需要另一个数组进行辅助，可是当我对我的内存空间的要求比较苛刻的话~如何才能解决呢~？

**利用DeleteMin产生的空穴**，熟悉堆的下滤(procateDown)操作的人都知道可以堆在删除最小（最大值）之后会产生一个空穴，那么我们大可以把删除的数据保存在空穴当中。当你需要一个从小到大的排序结果时，最好使用**大根堆（根节点最大的堆）**，这样话的~经过n-1次操作，你就可以得到一个排序好的数组了。之前答应要完成的堆排序算法已经OK了~但是使用Objective-C编写的，但原理都一样~[算法链接](https://github.com/RexMa88/HeapSort)~=_=

#归并排序（Merge Sort）

再说Merge sort之前，先说另一个概念，**分治法(divide and conquer)**这种方法在麻省理工算法公开课的第一节课就被提及了~大意是把一个大的问题分解成若干小的问题去解决，我个人很喜欢分治法的这个概念，因为这个概念包含了哲学理念和方法论，在生活中也会应用到。

回到归并排序,归并排序实际上就是利用分治法与递归，先将一个待排序数组均分，再用递归再均分，一直分到只有两个元素的时候比较大小并返回，在两个元素比较大小返回，两两归并成为一个完整的排序数组，完成一趟排序之后，再返回上一级再两两排序归并，到最后一层，就是两个均分的已排好序的两个数组进行排序。得到一个完整的数组。

#快速排序（Quick Sort）

说起这个快速排序的发明人：Tony Hoare可真是个天才级别的人物啊，快排只是他的其中一个发明而已。Quick sort也利用分治法和递归，这里给出C的[算法链接](https://github.com/RexMa88/Quick-Sort)。

快排的主要思想是利用一个**枢纽元pivot**进行一次排序，一次排序之后pivot左边是小于pivot的数字集合，右边是大于pivot的数字集合。之后利用递归的思想对左边和右边的集合再去进行一趟排序。反复进行分治和递归，排序就成功了。

###关于枢纽元的选取

但是快排的Pivot选取十分的重要~如果你的Pivot选取是很糟糕的话~快排最坏的时间复杂度是O(n^2)，而**三数中值分割法**是一种很不错的方法。比如一个随机数组：8，1，4，9，6，3，5，2，7，0.左边的数值是8，右边的数值是0，中间的数值是L[(Left + Right)/2] = 6，所以Pivot = 6，这种方法虽然不能完全避免快排的最坏情况，但是可以在一定程度上避免最坏情况。


###关于代码部分

在快速排序的代码中，我做了一定的优化措施，但貌似被我给注释掉了...+_+...幸好只是注释掉了，当排序数组的数据数量不是很多的话，大概是20个左右~你就使用插入排序。

